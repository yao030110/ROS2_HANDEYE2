#!/usr/bin/env python3
"""
get_relative_pose.py - 独立获取Tag到末端执行器的相对位姿

此脚本会：
1. 连接到ROS 2系统
2. 获取必要的TF变换
3. 计算Tag到末端执行器的相对位姿
4. 以清晰格式输出结果
5. 退出程序

用法:
    ros2 run your_package get_relative_pose.py [--ee-frame END_EFFECTOR_FRAME] [--timeout TIMEOUT]

示例:
    ros2 run your_package get_relative_pose.py
    ros2 run your_package get_relative_pose.py --ee-frame panda_link8 --timeout 5.0
"""

import rclpy
from rclpy.node import Node
import tf2_ros
from geometry_msgs.msg import TransformStamped
import argparse
import sys
import numpy as np
from scipy.spatial.transform import Rotation

class RelativePoseFetcher(Node):
    def __init__(self, ee_frame='panda_link8', timeout=3.0):
        super().__init__('relative_pose_fetcher')
        self.ee_frame = ee_frame
        self.timeout = timeout
        self.tf_buffer = tf2_ros.Buffer()
        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer, self)
        
    def fetch_relative_pose(self):
        """获取并返回Tag到末端执行器的相对位姿"""
        try:
            # 等待必要的TF可用
            self.get_logger().info(f"Waiting for TFs (timeout={self.timeout}s)...") 
            
            # 检查必要的TF是否可用
            start_time = self.get_clock().now()
            while (self.get_clock().now() - start_time).nanoseconds/1e9 < self.timeout:
                if self.tf_buffer.can_transform(
                    self.ee_frame, 
                    'camera_link', 
                    rclpy.time.Time()
                ) and self.tf_buffer.can_transform(
                    'camera_link', 
                    'tag', 
                    rclpy.time.Time()
                ):
                    break
                rclpy.spin_once(self, timeout_sec=0.1)
            else:
                raise RuntimeError("Timeout waiting for required TFs")
            
            # 获取相机到末端的变换
            T_ee_camera = self.tf_buffer.lookup_transform(
                self.ee_frame,
                'camera_link',
                rclpy.time.Time(),
                timeout=rclpy.duration.Duration(seconds=1.0)
            )
            
            # 获取相机到标签的变换
            T_camera_tag = self.tf_buffer.lookup_transform(
                'camera_link',
                'tag',
                rclpy.time.Time(),
                timeout=rclpy.duration.Duration(seconds=1.0)
            )
            
            # 计算末端到标签的变换: T_ee_tag = T_ee_camera × T_camera_tag
            T_ee_tag = self.multiply_transforms(T_ee_camera, T_camera_tag)
            
            # 计算标签到末端的变换（我们想要保持的相对关系）: T_tag_ee = T_ee_tag⁻¹
            T_tag_ee = self.inverse_transform(T_ee_tag)
            
            return T_tag_ee
            
        except Exception as e:
            self.get_logger().error(f"Failed to fetch relative pose: {str(e)}")
            return None
    
    def multiply_transforms(self, T1, T2):
        """组合两个变换: T_result = T1 × T2"""
        # 提取平移和旋转
        t1 = np.array([
            T1.transform.translation.x,
            T1.transform.translation.y,
            T1.transform.translation.z
        ])
        r1 = Rotation.from_quat([
            T1.transform.rotation.x,
            T1.transform.rotation.y,
            T1.transform.rotation.z,
            T1.transform.rotation.w
        ])
        
        t2 = np.array([
            T2.transform.translation.x,
            T2.transform.translation.y,
            T2.transform.translation.z
        ])
        r2 = Rotation.from_quat([
            T2.transform.rotation.x,
            T2.transform.rotation.y,
            T2.transform.rotation.z,
            T2.transform.rotation.w
        ])
        
        # 组合旋转
        r_result = r1 * r2
        
        # 组合平移: t_result = t1 + R1*t2
        t_result = t1 + r1.apply(t2)
        
        # 创建结果变换
        result = TransformStamped()
        result.transform.translation.x = t_result[0]
        result.transform.translation.y = t_result[1]
        result.transform.translation.z = t_result[2]
        
        quat = r_result.as_quat()
        result.transform.rotation.x = quat[0]
        result.transform.rotation.y = quat[1]
        result.transform.rotation.z = quat[2]
        result.transform.rotation.w = quat[3]
        
        return result
    
    def inverse_transform(self, T):
        """计算变换的逆"""
        # 提取平移和旋转
        t = np.array([
            T.transform.translation.x,
            T.transform.translation.y,
            T.transform.translation.z
        ])
        r = Rotation.from_quat([
            T.transform.rotation.x,
            T.transform.rotation.y,
            T.transform.rotation.z,
            T.transform.rotation.w
        ])
        
        # 计算逆变换
        r_inv = r.inv()
        t_inv = -r_inv.apply(t)
        
        # 创建逆变换
        result = TransformStamped()
        result.transform.translation.x = t_inv[0]
        result.transform.translation.y = t_inv[1]
        result.transform.translation.z = t_inv[2]
        
        quat = r_inv.as_quat()
        result.transform.rotation.x = quat[0]
        result.transform.rotation.y = quat[1]
        result.transform.rotation.z = quat[2]
        result.transform.rotation.w = quat[3]
        
        return result
    
    def format_transform(self, T):
        """格式化变换为可读字符串"""
        # 提取平移
        tx = T.transform.translation.x
        ty = T.transform.translation.y
        tz = T.transform.translation.z
        
        # 提取旋转（转换为欧拉角）
        r = Rotation.from_quat([
            T.transform.rotation.x,
            T.transform.rotation.y,
            T.transform.rotation.z,
            T.transform.rotation.w
        ])
        euler = r.as_euler('xyz', degrees=True)
        
        # 格式化输出
        output = []
        output.append("\n=== Tag 到 末端执行器 的相对位姿 ===")
        output.append(f"位置 (m): x = {tx:.3f}, y = {ty:.3f}, z = {tz:.3f}")
        output.append(f"方向 (°): roll = {euler[0]:.1f}, pitch = {euler[1]:.1f}, yaw = {euler[2]:.1f}")
        output.append("\n此位姿可用于保持一致的跟踪关系：")
        output.append("当标签移动时，末端执行器应移动相同位移以维持此相对关系")
        output.append("==================================")
        
        return "\n".join(output)

def main(args=None):
    # 解析命令行参数
    parser = argparse.ArgumentParser(description='获取Tag到末端执行器的相对位姿')
    parser.add_argument('--ee-frame', type=str, default='panda_link8',
                        help='末端执行器坐标系 (默认: panda_link8)')
    parser.add_argument('--timeout', type=float, default=3.0,
                        help='等待TF的超时时间(秒) (默认: 3.0)')
    parsed_args, _ = parser.parse_known_args()
    
    # 初始化ROS 2
    rclpy.init(args=args)
    
    try:
        # 创建节点
        node = RelativePoseFetcher(
            ee_frame=parsed_args.ee_frame,
            timeout=parsed_args.timeout
        )
        
        # 获取相对位姿
        relative_pose = node.fetch_relative_pose()
        
        if relative_pose:
            # 格式化并打印结果
            print(node.format_transform(relative_pose))
            node.get_logger().info("Relative pose successfully fetched!")
            
            # 以JSON格式输出（便于程序解析）
            print("\nJSON格式 (可用于程序输入):")
            print("{")
            print(f'  "position": {{{tx:.6f}, {ty:.6f}, {tz:.6f}}},')
            print(f'  "orientation": {{{quat[0]:.6f}, {quat[1]:.6f}, {quat[2]:.6f}, {quat[3]:.6f}}}')
            print("}")
            
            # 退出成功
            sys.exit(0)
        else:
            node.get_logger().error("Failed to fetch relative pose")
            sys.exit(1)
            
    except KeyboardInterrupt:
        pass
    finally:
        # 清理资源
        rclpy.shutdown()

if __name__ == '__main__':
    main()